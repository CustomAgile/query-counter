<!DOCTYPE html>
<html>
<head>
    <title>query-counter-1.2.1</title>
    <!--  (c) 2019 Custom Agile.  All Rights Reserved. -->
    <!--  Build Date: Tue Sep 17 2019 11:37:40 GMT-0700 (Pacific Daylight Time) -->

    <script type="text/javascript">
        var APP_BUILD_DATE = "Tue Sep 17 2019 11:37:40 GMT-0700 (Pacific Daylight Time)";
        var CHECKSUM = 224973011223;
    </script>

    <script type="text/javascript" src="/apps/2.1/sdk.js"></script>

    <script type="text/javascript">
        Rally.onReady(function() {
             
Ext.define('Utils.AncestorPiAppFilter', {
    alias: 'plugin.UtilsAncestorPiAppFilter',
    mixins: [
        'Ext.AbstractPlugin',
        'Rally.Messageable'
    ],
    extend: 'Ext.Component',

    statics: {
        RENDER_AREA_ID: 'utils-ancestor-pi-app-filter',
        PANEL_RENDER_AREA_ID: 'multi-level-pi-app-filter-panel'
    },

    config: {
        /**
         * @cfg {Boolean}
         * The id of the component where the plugin will render its controls
         */
        renderAreaId: 'utils-ancestor-pi-app-filter',

        /**
         * @cfg {String}
         * The id of the component where the filter button will render itself
         */
        btnRenderAreaId: 'utils-ancestor-pi-app-filter',

        /**
         * @cfg {String}
         * The id of the component where the tabbed filter panel will render itself
         */
        panelRenderAreaId: 'multi-level-pi-app-filter-panel',

        /**
         * @cfg {Boolean}
         * Set to false to prevent app from displaying a multi-level PI filter
         */
        displayMultiLevelFilter: true,

        /**
         * @cfg {Boolean}
         * Set to true to indicate that this component is a publisher of events
         * to other apps using this plugin
         */
        publisher: false,

        /**
         * @cfg {Boolean}
         * Set to false to prevent the '-- None --' selection option if your app can't support
         * querying by a null ancestor (e.g. Lookback _ItemHierarchy)
         */
        allowNoEntry: true,

        /**
         * @cfg {Object}
         * Config applied to the app settings components
         */
        settingsConfig: {},

        /**
         * @cfg {Object}
         * Fetch list for PI Selector
         */
        defaultFetch: true,

        /**
         * @cfg {Array}
         * Whitelist array for inline filters
         */
        whiteListFields: ['Tags', 'Milstones'],

        /**
         * @cfg {Array}
         * Blacklist array for inline filters
         */
        blackListFields: [],

        /**
         * @cfg {Boolean}
         * Setting for inlineFilterButtonConfig
         */
        filterChildren: false,

        /**
         * @cfg {String}
         * Label of the Portfolio Item Type picker
         */
        ancestorLabel: 'With ancestor',

        /**
         * @cfg {Number}
         * Width of the Portfolio Item Type picker label
         */
        ancestorLabelWidth: 110,

        /**
         * @cfg {String}
         * Label of the Portfolio Item Type picker when shown with the ancestor filter
         */
        ownerLabel: 'and owned by',

        /**
         * @cfg {String}
         * Label of the Portfolio Item Type picker when shown by itself
         */
        ownerOnlyLabel: 'Owned by',

        /**
         * @cfg {Number}
         * Width of the Portfolio Item Type picker label
         */
        ownerLabelWidth: 110,


        /**
         * @cfg {Number}
         * Style of the Portfolio Item Type picker label
         */
        labelStyle: 'font-size: medium',

        /**
         * @cfg {Number}
         * Minimum width for single row layout
         */
        singleRowMinWidth: 840,

        /**
         * @cfg {Array}
         * Field list for multi-level filter panel
         */
        defaultFilterFields: ['ArtifactSearch', 'Owner'],

        /**
         * @cfg {Boolean}
         * Set to true to hide filters on load
         */
        filtersHidden: false,

        /**
         * @cfg {Boolean}
         * Set to true to hide advanced filters on load
         */
        advancedFilterCollapsed: false
    },
    filterControls: [],
    portfolioItemTypes: [],
    readyDeferred: null,
    piTypesDeferred: null,
    isSubscriber: false,
    changeSubscribers: [],
    publishedValue: {},

    constructor: function () {
        this.callParent(arguments);
        this._setupPubSub();
        Ext.tip.QuickTipManager.init();
    },

    initComponent: function () {
        this.callParent(arguments);
        this.addEvents('ready', 'select', 'change');
    },

    init: function (cmp) {
        this.cmp = cmp;

        this.cmp.on('resize', this._onCmpResize, this);

        // Get the area where plugin controls will render
        this.renderArea = this.cmp.down('#' + this.renderAreaId);

        // Get the area where filter button will render
        this.btnRenderArea = this.cmp.down('#' + this.btnRenderAreaId);

        // Get the area where tabbed filter panel will render
        this.panelRenderArea = this.cmp.down('#' + this.panelRenderAreaId);

        // Extend app settings fields
        var cmpGetSettingsFields = this.cmp.getSettingsFields;
        this.cmp.getSettingsFields = function () {
            return this._getSettingsFields(cmpGetSettingsFields.apply(cmp, arguments));
        }.bind(this);

        // Extend app default settings fields
        var appDefaults = this.cmp.defaultSettings;
        appDefaults['Utils.AncestorPiAppFilter.enableAncestorPiFilter2'] = false;
        appDefaults['Utils.AncestorPiAppFilter.projectScope'] = 'current';
        appDefaults['Utils.AncestorPiAppFilter.enableMultiLevelPiFilter'] = false;
        this.cmp.setDefaultSettings(appDefaults);

        Ext.override(Rally.ui.inlinefilter.InlineFilterPanel, {
            // We don't want chevrons in the tab panel
            _alignChevron: function () {
                if (this.chevron) { this.chevron.hide(); }
            }
        });

        // Add the control components then fire ready
        Rally.data.util.PortfolioItemHelper.getPortfolioItemTypes().then({
            scope: this,
            success: function (piTypes) {
                this.portfolioItemTypes = piTypes;
                Promise.all([this._addAncestorControls(), this._addFilters()]).then(
                    function () {
                        this._setReady();
                    }.bind(this),
                    function (error) {
                        Rally.ui.notify.Notifier.showError({ message: error });
                        this._setReady();
                    }.bind(this)
                );
            },
            failure: function () {
                Rally.ui.notify.Notifier.showError({ message: 'Failed to fetch portfolio item types for multi-level filter' });
            }
        });
    },

    notifySubscribers: function (changeType) {
        var data = this._getValue();
        data.changeType = changeType;
        _.each(this.changeSubscribers, function (subscriberName) {
            this.publish(subscriberName, data);
        }, this);
    },

    // Returns a filter that will ensure results are children of the
    // selected ancestor portfolio item. type is the TypeDefinition 
    // for the Portfolio Item level you wish to fetch.
    getAncestorFilterForType: function (type) {
        var filter;
        var modelName = type.toLowerCase();
        var currentValues = this._getValue();

        if (currentValues.piTypePath) {
            var selectedPiTypePath = currentValues.piTypePath;
            var selectedRecord = currentValues.isPiSelected;
            var selectedPi = currentValues.pi;
            var pisAbove = this._piTypeAncestors(modelName, selectedPiTypePath);
            if (selectedRecord && selectedPi !== null && pisAbove !== null) {
                var property = this._propertyPrefix(modelName, pisAbove);
                if (property) {
                    filter = new Rally.data.wsapi.Filter({
                        property: property,
                        value: selectedPi
                    });
                }
            }
            else if (selectedPi !== null) {
                // Filter out any items of this type because the ancestor pi filter is
                // enabled, but this type doesn't have any pi ancestor types
                filter = new Rally.data.wsapi.Filter({
                    property: 'ObjectID',
                    value: 0
                });
            }
        }

        return filter;
    },

    // Returns an array containing all of the filters applied in the
    // multi-level filter as well as the selected ancestor PI if one
    // is selected. 
    // type is the TypeDefinition.TypePath for the Portfolio Item level you wish to fetch.
    getAllFiltersForType: async function (type, includeFiltersBelowType) {
        let ancestorFilter = this.getAncestorFilterForType(type);
        let filters = ancestorFilter ? [ancestorFilter] : [];
        let multiFilters = await this.getMultiLevelFiltersForType(type, includeFiltersBelowType);
        filters = filters.concat(multiFilters);

        return filters;
    },

    // Returns an array containing all of the filters applied in the multi-level filter for a given PI type. 
    // Type is the TypeDefinition.TypePath for the Portfolio Item level you wish to fetch.
    getMultiLevelFiltersForType: async function (type, includeFiltersBelowType) {
        let filters = [];
        let modelName = type.toLowerCase();
        let multiLevelFilters = this.getMultiLevelFilters();
        let keys = Object.keys(multiLevelFilters);

        for (let i = 0; i < keys.length; i++) {
            let currentType = keys[i];
            let currentFilters = multiLevelFilters[currentType];

            if (currentFilters.length) {
                // If scoping all projects, filter releases by name instead of value
                await this._convertReleaseFilters(currentFilters);

                // If we're at the given level, just add the filters
                if (modelName === currentType.toLowerCase()) {
                    filters = filters.concat(currentFilters);
                }
                // If we're at a level above the given level, convert filters to fit given level
                else {
                    let parentFilters = await this._getParentFilters(modelName, currentType, currentFilters);
                    filters = filters.concat(parentFilters);
                }
            }
        }

        // If building a hierarchy from top level down, we don't need to include filters
        // below the given type (e.g. a timeline app). Otherwise if being used for an app
        // that only displays one PI type, we need to include those lower filters
        if (includeFiltersBelowType && Ext.String.startsWith(type.toLowerCase(), 'portfolioitem')) {
            let childFilter = await this._getChildFiltersForType(type, multiLevelFilters);
            if (childFilter) {
                filters.push(childFilter);
            }
        }

        return filters;
    },

    // Returns an array containing all of the filters applied to a specific PI level.
    // type is the TypeDefinition.TypePath for the Portfolio Item level you wish to fetch.
    getFiltersOfSingleType: async function (type) {
        let filters = [];
        let modelName = type.toLowerCase();
        let multiLevelFilters = this.getMultiLevelFilters();
        let keys = Object.keys(multiLevelFilters);

        for (let i = 0; i < keys.length; i++) {
            let key = keys[i];
            let val = multiLevelFilters[key];
            if (modelName === key.toLowerCase()) {
                await this._convertReleaseFilters(val);
                filters = filters.concat(val);
            }
        }

        return filters;
    },

    // Returns an object containing all of the filters applied in the multi-level
    // filter. Keys are the type definition field and the resulting values are arrays
    // of filters
    getMultiLevelFilters: function () {
        if (this._isSubscriber()) {
            return this.publishedValue.filters;
        }

        var filters = {};
        _.each(this.filterControls, function (filterControl) {
            let typeName = (filterControl.inlineFilterButton.modelNames) || 'unknown';
            filters[typeName] = filterControl.inlineFilterButton.getFilters();
        });

        return filters;
    },

    // Starting at the lowest PI type, get a list of IDs that fit the given filter. 
    // Traverse up the PI hierarchy until reaching the given type and return a list of IDs
    // for that type that fit all filters from below
    // Returns an array of object IDs
    _getChildFiltersForType: async function (type, filters) {
        let idFilter;
        // PI types are in order lowest to highest
        for (let i = 0; i < this.portfolioItemTypes.length; i++) {
            let currentType = this.portfolioItemTypes[i].get('TypePath');
            let currentFilter = filters[currentType];
            if (currentType.toLowerCase() === type.toLowerCase()) {
                break;
            }
            if ((currentFilter && currentFilter.length) || idFilter) {
                if (!currentFilter) {
                    currentFilter = [];
                }
                if (idFilter) {
                    currentFilter.push(idFilter);
                }

                // To reduce the number of results returned, we include filters of higher level PI types
                for (let j = i + 1; j < this.portfolioItemTypes.length; j++) {
                    let parentType = this.portfolioItemTypes[j].get('TypePath');
                    let parentFilters = await this._getParentFilters(currentType, parentType, filters[parentType]);
                    currentFilter = currentFilter.concat(parentFilters);
                }

                let ancestor = this.getAncestorFilterForType(type);
                if (ancestor && ancestor.value) {
                    currentFilter.push(ancestor);
                }

                let records = await new Promise(function (resolve, reject) { this._getFilteredIds(currentFilter, currentType, resolve, reject); }.bind(this)).catch((e) => {
                    throw new Error(e);
                });

                if (records.length) {
                    let parents = _.map(records, function (id) { return (id.get('Parent') && id.get('Parent').ObjectID) || 0; });
                    idFilter = new Rally.data.wsapi.Filter({
                        property: 'ObjectID',
                        operator: 'in',
                        value: _.uniq(parents)
                    });
                }
                else {
                    idFilter = new Rally.data.wsapi.Filter({
                        property: 'ObjectID',
                        operator: '=',
                        value: 0
                    });
                }
            }
        }
        return idFilter;
    },

    // Given a type and a parent type and array of parent filters, convert the filters
    // to apply to the given type
    _getParentFilters: async function (type, parentType, parentFilters) {
        let pisAbove = this._piTypeAncestors(type, parentType);

        if (pisAbove !== null) {
            let parentProperty = this._propertyPrefix(type, pisAbove);
            if (parentProperty) {
                let currentLevelFilters = [];
                let hasCustomFieldFilters = this._hasCustomFilters(parentFilters);
                _.each(parentFilters, function (filter) {
                    let prop = filter.property;
                    if (!hasCustomFieldFilters) {
                        prop = `${parentProperty}.${prop}`;
                    }

                    currentLevelFilters.push(new Rally.data.wsapi.Filter({
                        property: prop,
                        operator: filter.operator,
                        value: filter.value
                    }));
                }.bind(this));

                // If filters on custom fields exist, lets get a list of IDs at that level and use those IDs as our filter
                if (hasCustomFieldFilters) {
                    let parentIDs = [];
                    try {
                        parentIDs = await new Promise(function (resolve, reject) { this._getFilteredIds(currentLevelFilters, parentType, resolve, reject); }.bind(this)).catch((e) => {
                            throw new Error(e);
                        });
                        if (parentIDs.length) {
                            return new Rally.data.wsapi.Filter({
                                property: parentProperty + '.ObjectID',
                                operator: 'in',
                                value: _.map(parentIDs, function (id) { return id.get('ObjectID'); })
                            });
                        }
                        else {
                            return new Rally.data.wsapi.Filter({
                                property: parentProperty + '.ObjectID',
                                operator: '=',
                                value: 0
                            });
                        }
                    }
                    catch (e) {
                        return [new Rally.data.wsapi.Filter({
                            property: parentProperty + '.ObjectID',
                            operator: '=',
                            value: 0
                        })];
                    }
                }
                else {
                    return currentLevelFilters;
                }
            }
        }
        return [];
    },

    _hasCustomFilters: function (filters) {
        for (let filter of filters) {
            // Rally has a hard time filtering on custom dropdown fields on parents (probably
            // not indexed) so we check to see if any are applied
            if (filter.property.indexOf('c_') !== -1 && typeof filter.value === 'string') {
                return true;
            }
        }
        return false;
    },

    // Takes an array of filters. If scoping across all projects, we need to update any release
    // filters to filter on the release name rather than the release value
    _convertReleaseFilters: async function (filters) {
        if (this.getIgnoreProjectScope()) {
            for (let i = 0; i < filters.length; i++) {
                if (filters[i].property === 'Release') {
                    let release = await this._getRelease(filters[i].value);
                    if (release) {
                        filters[i] = new Rally.data.wsapi.Filter({
                            property: 'Release.Name',
                            value: release.Name
                        });
                    }
                }
            }
        }
    },

    _getRelease: async function (releaseVal) {
        let deferred = Ext.create('Deft.Deferred');

        Ext.Ajax.request({
            url: Ext.String.format('/slm/webservice/v2.0{0}?fetch=Name', releaseVal),
            success(response) {
                if (response && response.responseText) {
                    let obj = Ext.JSON.decode(response.responseText);
                    if (obj && obj.Release) {
                        deferred.resolve(obj.Release);
                    }
                    else {
                        deferred.resolve(null);
                    }
                } else {
                    deferred.resolve(null);
                }
            }
        });

        return deferred.promise;
    },

    getSelectedPiRecord: function () {
        return this._getValue().piRecord;
    },

    getIgnoreProjectScope: function () {
        return this._getValue().ignoreProjectScope;
    },

    // Returns an object of states for all of the inline filters
    // Used for getting and setting shared views
    getMultiLevelFilterStates: function () {
        if (this._isSubscriber()) {
            return this.publishedValue.filterStates;
        }

        var states = {};
        _.each(this.filterControls, function (filterControl) {
            let typeName = (filterControl.inlineFilterButton.modelNames) || 'unknown';
            states[typeName] = filterControl.inlineFilterButton.getState();
        });

        return states;
    },

    getModels: function () {
        return this.models;
    },

    getPortfolioItemTypes: function () {
        return this.portfolioItemTypes;
    },

    // Sets the states of the inline filters
    // Used when applying a shared view to the filters
    setMultiLevelFilterStates: function (states) {
        if (!this._isSubscriber()) {
            this.tabPanel.removeAll();
            for (let key in states) {
                if (states.hasOwnProperty(key)) {
                    for (let i = 0; i < this.filterControls.length; i++) {
                        let typeName = (this.filterControls[i].inlineFilterButton.modelNames) || 'unknown';
                        if (typeName === key) {
                            this.filterControls[i].inlineFilterButton.applyState(states[key]);
                        }
                    }
                }
            }
            setTimeout(function () { this.tabPanel.setActiveTab(0); }.bind(this), 1500);
        }
    },

    // Returns an array of records fitting the given filters
    _getFilteredIds: function (filters, model, resolve, reject) {
        let dataContext = Rally.getApp().getContext().getDataContext();
        if (this.getIgnoreProjectScope()) {
            dataContext.project = null;
        }

        let ancestor = this.getAncestorFilterForType(model);
        if (ancestor && ancestor.value) {
            filters.push(ancestor);
        }

        let store = Ext.create('Rally.data.wsapi.Store', {
            autoLoad: false,
            context: dataContext,
            filters,
            model,
            fetch: ['ObjectID', 'Parent'],
            limit: Infinity,
            enablePostGet: true
        });

        store.load().then({
            scope: this,
            success: function (records) {
                resolve(records);
            },
            failure: function () {
                //Rally.ui.notify.Notifier.showError({ message: 'Multi-level filter failed while filtering out items above or below selected portfolio item type. Result set was probably too large.' });
                reject('Multi-level filter failed while filtering out items above or below selected portfolio item type. Result set was probably too large.');
                //resolve([]);
                // reject('Multi-level filter failed while filtering out items above or below selected portfolio item type. Result set was probably too large.'); // TODO REJECT!!!!!
            }
        });
    },

    _getLowestFilteredOrdinal: function () {

    },

    _setupPubSub: function () {
        if (this.publisher) {
            this.subscribe(this, 'registerChangeSubscriber', function (subscriberName) {
                // Register new unique subscribers
                if (!_.contains(this.changeSubscribers, subscriberName)) {
                    this.changeSubscribers.push(subscriberName);
                }
                this.publish(subscriberName, this._getValue());
            }, this);
            // Ask any existing subscribers to re-register
            this.publish('reRegisterChangeSubscriber');
        }
        else {
            this.subscriberEventName = Rally.getApp().getAppId() + this.$className;
            // Subscribe to a channel dedicated to this app
            this.subscribe(this, this.subscriberEventName, function (data) {
                if (this.intervalTimer) {
                    clearInterval(this.intervalTimer);
                    delete this.intervalTimer;
                }
                if (!this.isSubscriber) {
                    this.isSubscriber = true;
                    this._hideControlCmp();
                }
                this.publishedValue = data;

                // Default to an ancestor change event for backwards compatibility
                if (data.changeType === 'ancestor' || !data.changeType) {
                    this._onSelect();
                }
                else {
                    this._onChange();
                }
            }, this);
            // Attempt to register with a publisher (if one exists)
            this.publish('registerChangeSubscriber', this.subscriberEventName);
            this.intervalTimer = setInterval(function () {
                this.publish('registerChangeSubscriber', this.subscriberEventName);
            }.bind(this), 500);
            this.subscribe(this, 'reRegisterChangeSubscriber', function () {
                this.publish('registerChangeSubscriber', this.subscriberEventName);
            }, this);
        }
    },

    _getValue: function () {
        var result = {};
        if (this._isSubscriber()) {
            result = this.publishedValue || {};
        }
        else {
            if (this.piTypeSelector) {
                var selectedPiType = this.piTypeSelector.getRecord();
                if (selectedPiType && this.piSelector) {
                    var selectedPiTypePath = selectedPiType.get('TypePath');
                    var selectedRecord = this.piSelector.getRecord();
                    var selectedPi = this.piSelector.getValue();
                    _.merge(result, {
                        piTypePath: selectedPiTypePath,
                        isPiSelected: !!selectedPi,
                        pi: selectedPi,
                        piRecord: selectedRecord
                    });
                }
            }
            result.ignoreProjectScope = this._ignoreProjectScope();
            result.filters = this.getMultiLevelFilters();
            result.filterStates = this.getMultiLevelFilterStates();
        }
        return result;
    },

    _setReady: function () {
        this._updateReleaseValues();

        this.ready = true;

        if (this._isSubscriber() && this.tabPanel) {
            this.tabPanel.hide();
        }

        if (this._isSubscriber() && this.showFiltersBtn) {
            this.showFiltersBtn.hide();
        }

        this.fireEvent('ready', this);
    },

    // Ancestor filter dropdowns have been selected
    _onSelect: function () {
        if (this.ready) {
            this.fireEvent('select', this);
        }
    },

    // Multi-level filters have changed
    _onChange: function () {
        if (this.ready) {
            this.fireEvent('change', this.getMultiLevelFilters());
        }
    },

    _getSettingsFields: function (fields) {
        var currentSettings = Rally.getApp().getSettings();
        if (!currentSettings.hasOwnProperty('Utils.AncestorPiAppFilter.projectScope')) {
            currentSettings['Utils.AncestorPiAppFilter.projectScope'] = 'user';
        }
        var pluginSettingsFields = [{
            xtype: 'rallycheckboxfield',
            id: 'Utils.AncestorPiAppFilter.enableAncestorPiFilter2',
            name: 'Utils.AncestorPiAppFilter.enableAncestorPiFilter2',
            fieldLabel: 'Filter artifacts by ancestor portfolio item',
        }, {
            xtype: 'rallyportfolioitemtypecombobox',
            id: 'Utils.AncestorPiAppFilter.defaultPiType',
            name: 'Utils.AncestorPiAppFilter.defaultPiType',
            fieldLabel: "Default Portfolio Item type",
            valueField: 'TypePath',
            allowNoEntry: false,
            defaultSelectionPosition: 'last',
            // Disable the preference enabled combo box plugin so that this control value is app specific
            plugins: []
        },
        {
            xtype: 'radiogroup',
            fieldLabel: 'Show artifacts from',
            columns: 1,
            vertical: true,
            allowBlank: false,
            items: [{
                boxLabel: "User's current project(s).",
                name: 'Utils.AncestorPiAppFilter.projectScope',
                inputValue: 'current',
                checked: 'current' === currentSettings['Utils.AncestorPiAppFilter.projectScope']
            }, {
                boxLabel: "All projects in workspace.",
                name: 'Utils.AncestorPiAppFilter.projectScope',
                inputValue: 'workspace',
                checked: 'workspace' === currentSettings['Utils.AncestorPiAppFilter.projectScope']
            }, {
                boxLabel: 'User selectable (either current project(s) or all projects in workspace).',
                name: 'Utils.AncestorPiAppFilter.projectScope',
                inputValue: 'user',
                checked: 'user' === currentSettings['Utils.AncestorPiAppFilter.projectScope']
            },],
            listeners: {
                scope: this,
                change: function () {
                    return;
                }
            }
        },
        {
            xtype: 'rallycheckboxfield',
            id: 'Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter',
            name: 'Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter',
            fieldLabel: 'Enable multi-level portfolio item filter',
        }
        ];
        pluginSettingsFields = _.map(pluginSettingsFields, function (pluginSettingsField) {
            return _.merge(pluginSettingsField, this.settingsConfig);
        }, this);
        // apply any settings config to each field added by the plugin
        return pluginSettingsFields.concat(fields || []);
    },

    // When changing projects, if a release filter was previously applied, the inline filter state remembers the release
    // filter, but fails to populate the comobobox with the release name, which becomes misleading to 
    // the end user. This hack finds the release name and shoves it into the combobox.
    _updateReleaseValues: function () {
        _.each(this.filterControls, function (filter) {
            _.each(filter.inlineFilterButton.inlineFilterPanel.advancedFilterPanel.advancedFilterRows.rows, function (row) {
                if (row.name === 'Release' && row._valueFieldIsValid()) {
                    _.each(row.items.items, function (rowItem) {
                        if (rowItem.xtype === 'rallyreleasecombobox') {
                            this._getRelease(rowItem.originalValue).then(function (release) {
                                if (release) {
                                    rowItem.rawValue = release.Name;
                                }
                            });
                        }
                    }, this);
                }
            }, this);
        }, this);
    },

    // Requires that app settings are available (e.g. from 'beforelaunch')
    _addAncestorControls: function () {
        var controlsLayout = {
            type: 'hbox',
            align: 'middle',
            defaultMargins: '0 10 0 0'
        };
        var ownerLabelWidth = this.ownerLabelWidth;
        if (this.cmp.getWidth() < this.singleRowMinWidth) {
            controlsLayout = 'vbox';
            ownerLabelWidth = this.ancestorLabelWidth;
        }
        var scopeControlByItself = false;
        if (this._showAncestorFilter() === false && this._showIgnoreProjectScopeControl() === true) {
            scopeControlByItself = true;
        }
        var controls = {
            xtype: 'container',
            id: 'controlsArea',
            overflowX: 'auto',
            layout: {
                type: 'hbox',
                align: 'top'
            },
            items: [{
                xtype: 'container',
                id: 'pubSubIndicatorArea',
                width: 25,
                padding: '6 5 0 0',
                hidden: !this.publisher && !this._isSubscriber(),
                items: [{
                    xtype: 'component',
                    id: 'publisherIndicator',
                    html: '<span class="icon-bullhorn icon-large"></span>',
                    hidden: !this.publisher
                },
                {
                    xtype: 'component',
                    id: 'subscriberIndicator',
                    html: '<span class="icon-link icon-large"></span>',
                    hidden: !this._isSubscriber()
                },
                ]
            }, {
                xtype: 'container',
                id: 'filtersArea',
                layout: controlsLayout,
                items: [{
                    xtype: 'container',
                    id: 'ancestorFilterArea',
                    layout: {
                        type: 'hbox',
                        align: 'middle'
                    },
                    items: [{
                        xtype: 'container',
                        id: 'piTypeArea',
                        layout: {
                            type: 'hbox',
                            align: 'middle'
                        },
                    },
                    {
                        xtype: 'container',
                        id: 'piSelectorArea',
                        layout: {
                            type: 'hbox',
                            align: 'middle',
                            padding: '0 0 0 5'
                        },
                    }
                    ]
                }, {
                    xtype: 'container',
                    itemId: 'scopeControlArea',
                    id: 'scopeControlArea',
                    width: 250,
                    layout: {
                        type: 'hbox',
                        align: 'middle'
                    },
                    items: [{
                        xtype: 'rallycombobox',
                        itemId: 'ignoreScopeControl',
                        id: 'ignoreScopeControl',
                        stateful: true,
                        stateId: this.cmp.getContext().getScopedStateId('Utils.AncestorPiAppFilter.ignoreProjectScopeControl'),
                        stateEvents: ['select'],
                        hidden: this._isSubscriber() || !this._showIgnoreProjectScopeControl(),
                        displayField: 'text',
                        valueField: 'value',
                        labelStyle: this.labelStyle,
                        labelWidth: ownerLabelWidth,
                        fieldLabel: scopeControlByItself ? this.ownerOnlyLabel : this.ownerLabel,
                        // Don't set initial value with this component or it will override the state
                        storeConfig: {
                            fields: ['text', 'value'],
                            data: [{
                                text: "Current Project(s)",
                                value: false
                            }, {
                                text: "Any Project",
                                value: true
                            }]
                        },
                        listeners: {
                            scope: this,
                            change: function () {
                                this._onSelect();
                            }
                        },
                    }]
                }]
            }]
        };

        if (this.renderArea) {
            // Without this, the components are clipped on narrow windows
            this.renderArea.setOverflowXY('auto', 'auto');
            this.renderArea.add(controls);
        }

        this._addTooltips();

        // Need to get pi types sorted by ordinal lowest to highest for the filter logic to work
        return new Promise(function (resolve) {
            if (!this._isSubscriber() && this._showAncestorFilter()) {
                // Now create the pi type selector
                this._addPiTypeSelector().then(function () {
                    this._addPiSelector(this.piTypeSelector.getValue(), null).then(
                        function () {
                            resolve();
                        }.bind(this)
                    );
                }.bind(this));
            }
            else {
                resolve();
            }
        }.bind(this));
    },

    _addPiTypeSelector: function (initialValue) {
        return new Promise(function (resolve) {
            this.piTypeSelector = Ext.create('Rally.ui.combobox.PortfolioItemTypeComboBox', {
                xtype: 'rallyportfolioitemtypecombobox',
                id: 'Utils.AncestorPiAppFilter.piType',
                name: 'Utils.AncestorPiAppFilter.piType',
                width: 250,
                // Disable the preference enabled combo box plugin so that this control value is app specific
                plugins: [],
                stateful: true,
                stateId: this.cmp.getContext().getScopedStateId('Utils.AncestorPiAppFilter.piType'),
                stateEvents: ['select'],
                fieldLabel: this.ancestorLabel,
                labelWidth: this.ancestorLabelWidth,
                labelStyle: this.labelStyle,
                valueField: 'TypePath',
                value: initialValue || this._defaultPortfolioItemType(),
                allowNoEntry: false,
                defaultSelectionPosition: 'first',
                listeners: {
                    scope: this,
                    ready: function (combobox) {
                        // Unfortunately we cannot use the combobox store of PI types for our filter
                        // logic because it is sorted by ordinal from highest to lowest so that the
                        // picker options have a an order familiar to the user.

                        // Don't add the change listener until ready. This prevents us
                        // from adding and removing the pi selector multiple times during
                        // startup which causes a null ptr exception in that component
                        combobox.addListener({
                            scope: this,
                            change: this._onPiTypeChange
                        });
                        resolve();
                    }
                }
            });
            this.renderArea.down('#piTypeArea').add(this.piTypeSelector);
        }.bind(this));
    },

    _addTooltips: function () {
        Ext.tip.QuickTipManager.register({
            target: 'publisherIndicator',
            text: 'This app broadcasts filter settings to any enabled ancestor filtered apps (indicated with <span class="icon-link icon-large"></span>)',
            showDelay: 50,
            border: true
        });

        Ext.tip.QuickTipManager.register({
            target: 'subscriberIndicator',
            text: 'This app listens for filter settings from any enabled ancestor filter broadcast app (indicated with <span class="icon-bullhorn icon-large"></span>)',
            showDelay: 50,
            border: true
        });

        if (this._isSubscriber()) {
            Ext.tip.QuickTipManager.register({
                target: 'subscriberFilterIndicator',
                text: 'This app listens for filter settings from any enabled ancestor filter broadcast app (indicated with <span class="icon-bullhorn icon-large"></span>)',
                showDelay: 50,
                border: true
            });
        }
    },

    _onCmpResize: function (cmp, width) {
        var controlsLayout = {
            type: 'hbox',
            align: 'middle',
            defaultMargins: '0 10 0 0'
        };
        if (width < this.singleRowMinWidth) {
            controlsLayout = {
                type: 'vbox'
            };
        }
        var filtersArea = this.renderArea.down('#filtersArea');
        if (filtersArea) {
            var controlsArea = this.renderArea.down('#controlsArea');
            var filters = filtersArea.removeAll(false);
            var newFiltersArea = {
                xtype: 'container',
                id: 'filtersArea',
                layout: controlsLayout,
                items: filters,
                hidden: filtersArea.isHidden()
            };
            controlsArea.remove(filtersArea, false);
            controlsArea.add(newFiltersArea);
        }
    },

    _hideControlCmp: function () {
        if (this.renderArea) {
            this.renderArea.down('#pubSubIndicatorArea').show();
            this.renderArea.down('#subscriberIndicator').show();
            this.renderArea.down('#filtersArea').hide();
        }
    },

    _onPiTypeChange: function (piTypeSelector, newValue) {
        if (newValue) {
            let currentPi = this._getValue().pi;
            this._removePiSelector();
            this._addPiSelector(newValue).then(
                function () {
                    this._setReady();
                    // If an ancestor was selected it has now been cleared, so fire select event
                    if (currentPi) {
                        this._onSelect();
                    }
                }.bind(this)
            );
        }
    },

    _removePiSelector: function () {
        this.renderArea.down('#piSelectorArea').removeAll(true);
    },

    _addPiSelector: function (piType, initialValue) {
        return new Promise(function (resolve) {
            this.piSelector = Ext.create('Rally.ui.combobox.ArtifactSearchComboBox', {
                id: 'Utils.AncestorPiAppFilter.piSelector',
                width: 250,
                labelAlign: 'top',
                storeConfig: {
                    models: piType,
                    autoLoad: true,
                    fetch: this.defaultFetch,
                    context: {
                        project: null
                    }
                },
                queryDelay: 2000,
                typeAhead: false,
                validateOnChange: false,
                stateful: true,
                stateId: this.cmp.getContext().getScopedStateId('Utils.AncestorPiAppFilter.piSelector'),
                stateEvents: ['select'],
                valueField: '_ref',
                allowClear: true,
                clearValue: null,
                allowNoEntry: this.allowNoEntry,
                noEntryValue: '',
                value: initialValue || '',
                // forceSelection: false,
                defaultSelectionPosition: null,
                listeners: {
                    scope: this,
                    select: function () {
                        this._onSelect();
                    },
                    ready: function () {
                        resolve();
                    }
                }
            });
            // Allow this combobox to save null state (which is default behavior of
            // stateful mixin, but for some reason was overridden in combobox)
            Ext.override(this.piSelector, {
                saveState: function () {
                    var me = this,
                        id = me.stateful && me.getStateId(),
                        hasListeners = me.hasListeners,
                        state;

                    if (id) {
                        state = me.getState() || {}; //pass along for custom interactions
                        if (!hasListeners.beforestatesave || me.fireEvent('beforestatesave', me, state) !== false) {
                            Ext.state.Manager.set(id, state);
                            if (hasListeners.statesave) {
                                me.fireEvent('statesave', me, state);
                            }
                        }
                    }
                }
            });
            this.renderArea.down('#piSelectorArea').add(this.piSelector);
        }.bind(this));
    },

    _setPiSelector: function (piType, pi) {
        return new Promise(function (resolve) {
            this.piTypeSelector.suspendEvents(false);
            this.piTypeSelector.setValue(piType);
            this._removePiSelector();
            this._addPiSelector(piType, pi).then(function () {
                this.piSelector.setValue(pi);
                this.piTypeSelector.resumeEvents();
                resolve();
            }.bind(this));
        }.bind(this));
    },

    _showAncestorFilter: function () {
        return this.cmp.getSetting('Utils.AncestorPiAppFilter.enableAncestorPiFilter2');
    },

    _showIgnoreProjectScopeControl: function () {
        return this.cmp.getSetting('Utils.AncestorPiAppFilter.projectScope') === 'user';
    },

    _ignoreProjectScope: function () {
        if (this._isSubscriber()) {
            return this.publishedValue.ignoreProjectScope;
        }

        var result = false;
        if (this._showIgnoreProjectScopeControl()) {
            // If the control is shown, that values overrides the ignoreScope app setting
            result = this.renderArea.down('#ignoreScopeControl').getValue();
        }
        else if (this.cmp.getSetting('Utils.AncestorPiAppFilter.projectScope') === 'workspace') {
            result = true;
        }
        return result;
    },

    _isSubscriber: function () {
        return this.isSubscriber;
    },

    _defaultPortfolioItemType: function () {
        return this.cmp.getSetting('Utils.AncestorPiAppFilter.defaultPiType');
    },

    _propertyPrefix: function (typeName, piTypesAbove) {
        var property;
        if (typeName === 'hierarchicalrequirement' || typeName === 'userstory') {
            property = piTypesAbove[0].get('Name');
        }
        else if (typeName === 'defect') {
            property = 'Requirement.' + piTypesAbove[0].get('Name');
        }
        else if (Ext.String.startsWith(typeName.toLowerCase(), 'portfolioitem')) {
            property = 'Parent';
        }

        if (property) {
            // property already gets us to the lowest pi level above the current type
            // for each additional level, add a 'Parent' term, except for the last
            // type in the list which is the currently selected pi type ancestor
            _.forEach(piTypesAbove.slice(1), function () {
                property = property + '.Parent';
            }, this);
        }

        return property;
    },

    /**
     * Return a list of portfolio item types AT or below the selected pi type,
     * that are an ancestor of the given model, or null if there are no pi type
     * ancestors for the given model.
     */
    _piTypeAncestors: function (modelName, selectedPiTypePath) {
        var result = null;
        var selectedPiTypeIndex;
        var modelNamePiTypeIndex;

        if (_.contains(['hierarchicalrequirement', 'userstory', 'defect'], modelName)) {
            selectedPiTypeIndex = _.findIndex(this.portfolioItemTypes, function (piType) {
                return piType.get('TypePath').toLowerCase() === selectedPiTypePath.toLowerCase();
            });
            result = this.portfolioItemTypes.slice(0, selectedPiTypeIndex + 1);
        }
        else if (Ext.String.startsWith(modelName.toLowerCase(), 'portfolioitem')) {
            modelNamePiTypeIndex = _.findIndex(this.portfolioItemTypes, function (piType) {
                return piType.get('TypePath').toLowerCase() === modelName.toLowerCase();
            });
            selectedPiTypeIndex = _.findIndex(this.portfolioItemTypes, function (piType) {
                return piType.get('TypePath').toLowerCase() === selectedPiTypePath.toLowerCase();
            });

            if (modelNamePiTypeIndex < selectedPiTypeIndex) {
                // Don't include the current model pi in the list of ancestors
                // Include the selcted pi type ancestor
                result = this.portfolioItemTypes.slice(modelNamePiTypeIndex + 1, selectedPiTypeIndex + 1);
            }
        }

        return result;
    },

    /*
        Multi-Level Filter functions
    */
    _showMultiLevelFilter: function () {
        return this.cmp.getSetting('Utils.MultiLevelPiAppFilter.enableMultiLevelPiFilter');
    },

    _addFilters: function () {
        return new Promise(function (resolve, reject) {
            var promises = [];
            if (this._showMultiLevelFilter() && !this._isSubscriber()) {
                if (this.btnRenderArea) {
                    if (!this._isSubscriber()) {
                        this.showFiltersBtn = this.btnRenderArea.add(
                            {
                                xtype: 'rallybutton',
                                cls: this.filtersHidden ? 'secondary' : 'primary' + ' rly-small',
                                iconCls: 'icon-filter',
                                toolTipText: + this.filtersHidden ? 'Show' : 'Hide' + ' Filters',
                                handler: this._toggleFilters,
                                scope: this
                            }
                        );

                        var piTypePaths = _.map(this.portfolioItemTypes, function (piType) {
                            return piType.get('TypePath');
                        });
                        piTypePaths.reverse();

                        Rally.data.ModelFactory.getModels({
                            types: piTypePaths,
                            context: this.cmp.getContext(),
                            scope: this,
                            success: function (models) {
                                this.models = models;

                                this.tabPanel = this.panelRenderArea.add({
                                    xtype: 'tabpanel',
                                    width: '98%',
                                    cls: 'blue-tabs',
                                    minTabWidth: 100,
                                    plain: true,
                                    autoRender: true,
                                    hidden: this._isSubscriber(),
                                    hideMode: 'offsets',
                                    items: []
                                });

                                this.filterControls = [];

                                _.each(models, function (model, key) {
                                    promises.push(new Promise(function (newResolve) {
                                        let filterName = `inlineFilter${key}`;
                                        this.filterControls.push(Ext.create('Rally.ui.inlinefilter.InlineFilterControl', {
                                            xtype: 'rallyinlinefiltercontrol',
                                            name: filterName,
                                            autoRender: true,
                                            stateful: true,
                                            stateId: this.cmp.getContext().getScopedStateId(`multi-${filterName}-control`),
                                            itemId: filterName,
                                            context: this.cmp.getContext(),
                                            inlineFilterButtonConfig: {
                                                stateful: true,
                                                stateId: this.cmp.getContext().getScopedStateId(`multi-${filterName}`),
                                                context: this.cmp.getContext(),
                                                modelNames: key,
                                                filterChildren: this.filterChildren,
                                                inlineFilterPanelConfig: {
                                                    autoRender: true,
                                                    name: `${filterName}-panel`,
                                                    itemId: `${filterName}-panel`,
                                                    model: model,
                                                    padding: 5,
                                                    width: '98%',
                                                    context: this.cmp.getContext(),
                                                    quickFilterPanelConfig: {
                                                        defaultFields: this.defaultFilterFields,
                                                        addQuickFilterConfig: {
                                                            whiteListFields: this.whiteListFields,
                                                            blackListFields: this.blackListFields
                                                        }
                                                    },
                                                    advancedFilterPanelConfig: {
                                                        collapsed: this.advancedFilterCollapsed,
                                                        advancedFilterRowsConfig: {
                                                            propertyFieldConfig: {
                                                                blackListFields: this.blackListFields,
                                                                whiteListFields: this.whiteListFields
                                                            }
                                                        }
                                                    },
                                                },
                                                listeners: {
                                                    inlinefilterchange: this._onFilterChange,
                                                    inlinefilterready: function (panel) {
                                                        this._onFilterReady(panel);
                                                        newResolve();
                                                    },
                                                    scope: this
                                                }
                                            }
                                        }));
                                    }.bind(this)));
                                }, this);

                                Promise.all(promises).then(function () {
                                    if (!this._isSubscriber()) {
                                        this.clearAllButton = Ext.widget({
                                            xtype: 'rallybutton',
                                            itemId: 'clearAllButton',
                                            cls: 'secondary rly-small clear-all-filters-button',
                                            text: 'Clear All',
                                            margin: '3 9 3 0',
                                            hidden: !this._hasFilters(),
                                            listeners: {
                                                click: this._clearAllFilters,
                                                scope: this
                                            }
                                        });

                                        this.btnRenderArea.add(this.clearAllButton);
                                        this.tabPanel.setActiveTab(0);
                                        if (this.filtersHidden) {
                                            this.tabPanel.hide();
                                        }

                                        // Without this, the components are clipped on narrow windows
                                        this.btnRenderArea.setOverflowXY('auto', 'auto');
                                    }
                                    resolve();
                                }.bind(this));
                            },
                            failure: function () {
                                reject('Failed to fetch models for multi-level filter');
                            }
                        });
                    }
                    else {
                        this.btnRenderArea.add({
                            xtype: 'container',
                            id: 'filterSubIndicatorArea',
                            width: 25,
                            padding: '6 5 0 0',
                            items: [
                                {
                                    xtype: 'component',
                                    id: 'subscriberFilterIndicator',
                                    html: '<span class="icon-link icon-large"></span>'
                                }
                            ]
                        });
                        resolve();
                    }
                } else {
                    reject('Unable to find button render area for multi-level filter');
                }
            }
            else {
                resolve();
            }
        }.bind(this));
    },

    _clearAllFilters: function () {
        this.suspendEvents(false);
        this.suspendLayouts();

        // The quick filters don't properly clear if the filter isn't displayed
        let activeTab = this.tabPanel.getActiveTab();

        _.each(this.filterControls, function (filterControl) {
            try {
                this.tabPanel.setActiveTab(filterControl.tab);
                filterControl.inlineFilterButton.clearAllFilters();
            }
            catch (e) {
                console.log(e);
            }
        }.bind(this));

        this.tabPanel.setActiveTab(activeTab);

        if (this.clearAllButton) {
            this.clearAllButton.hide();
        }

        this.resumeEvents();
        this.resumeLayouts(false);
        this.updateLayout();
        this.fireEvent('change', this.getMultiLevelFilters());
    },

    _hasFilters: function () {
        var filters = this.getMultiLevelFilters();
        var returnVal = false;

        _.each(filters, function (filter) {
            if (filter.length) {
                returnVal = true;
            }
        });

        return returnVal;
    },

    _onFilterReady: function (panel) {
        panel.expand();
        let filterCount = panel.quickFilterPanel.getFilters().length + panel.advancedFilterPanel.getFilters().length;
        let modelName = (panel.model && panel.model.elementName) || 'unknown';

        let tab = this.tabPanel.add({
            title: modelName + (filterCount ? ` (${filterCount})` : ''),
            html: '',
            itemId: `${modelName}-tab`,

        });

        tab.add({
            xtype: 'container',
            layout: 'hbox',
            items: [panel]
        });

        panel.tab = tab;
    },

    _applyFilters: function () {
        this.suspendEvents(false);
        this.suspendLayouts();
        _.each(this.filterControls, function (filterControl) {
            filterControl.inlineFilterButton._applyFilters();
        });
        this.resumeEvents();
        this.resumeLayouts(false);
        this.updateLayout();
    },

    _onFilterChange: function () {
        if (this.clearAllButton) {
            if (this._hasFilters()) {
                this.clearAllButton.show();
            }
            else {
                this.clearAllButton.hide();
            }
        }

        _.each(this.filterControls, function (filterControl) {
            let typeName = (filterControl.inlineFilterButton.inlineFilterPanel.model.elementName) || 'unknown';
            this._setTabText(typeName, filterControl.inlineFilterButton.getFilters().length);
        }, this);

        if (this.ready) {
            this.fireEvent('change', this.getMultiLevelFilters());
        }
    },

    _setTabText: function (typeName, filterCount) {
        var titleText = filterCount ? `${typeName} (${filterCount})` : typeName;
        var tab = this.tabPanel.child(`#${typeName}-tab`);

        if (tab) { tab.setTitle(titleText); }
    },

    _toggleFilters: function (btn) {
        if (this.tabPanel.isHidden()) {
            this.tabPanel.show();
            btn.setToolTipText('Hide Filters');
            btn.addCls('primary');
            btn.removeCls('secondary');
        } else {
            this.tabPanel.hide();
            btn.setToolTipText('Show Filters');
            btn.addCls('secondary');
            btn.removeCls('primary');
        }
    }
});
/*! @source http://purl.eligrey.com/github/FileSaver.js/blob/master/FileSaver.js */
var saveAs=saveAs||function(e){"use strict";if(typeof e==="undefined"||typeof navigator!=="undefined"&&/MSIE [1-9]\./.test(navigator.userAgent)){return}var t=e.document,n=function(){return e.URL||e.webkitURL||e},r=t.createElementNS("http://www.w3.org/1999/xhtml","a"),o="download"in r,a=function(e){var t=new MouseEvent("click");e.dispatchEvent(t)},i=/constructor/i.test(e.HTMLElement)||e.safari,f=/CriOS\/[\d]+/.test(navigator.userAgent),u=function(t){(e.setImmediate||e.setTimeout)(function(){throw t},0)},s="application/octet-stream",d=1e3*40,c=function(e){var t=function(){if(typeof e==="string"){n().revokeObjectURL(e)}else{e.remove()}};setTimeout(t,d)},l=function(e,t,n){t=[].concat(t);var r=t.length;while(r--){var o=e["on"+t[r]];if(typeof o==="function"){try{o.call(e,n||e)}catch(a){u(a)}}}},p=function(e){if(/^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(e.type)){return new Blob([String.fromCharCode(65279),e],{type:e.type})}return e},v=function(t,u,d){if(!d){t=p(t)}var v=this,w=t.type,m=w===s,y,h=function(){l(v,"writestart progress write writeend".split(" "))},S=function(){if((f||m&&i)&&e.FileReader){var r=new FileReader;r.onloadend=function(){var t=f?r.result:r.result.replace(/^data:[^;]*;/,"data:attachment/file;");var n=e.open(t,"_blank");if(!n)e.location.href=t;t=undefined;v.readyState=v.DONE;h()};r.readAsDataURL(t);v.readyState=v.INIT;return}if(!y){y=n().createObjectURL(t)}if(m){e.location.href=y}else{var o=e.open(y,"_blank");if(!o){e.location.href=y}}v.readyState=v.DONE;h();c(y)};v.readyState=v.INIT;if(o){y=n().createObjectURL(t);setTimeout(function(){r.href=y;r.download=u;a(r);h();c(y);v.readyState=v.DONE});return}S()},w=v.prototype,m=function(e,t,n){return new v(e,t||e.name||"download",n)};if(typeof navigator!=="undefined"&&navigator.msSaveOrOpenBlob){return function(e,t,n){t=t||e.name||"download";if(!n){e=p(e)}return navigator.msSaveOrOpenBlob(e,t)}}w.abort=function(){};w.readyState=w.INIT=0;w.WRITING=1;w.DONE=2;w.error=w.onwritestart=w.onprogress=w.onwrite=w.onabort=w.onerror=w.onwriteend=null;return m}(typeof self!=="undefined"&&self||typeof window!=="undefined"&&window||this.content);if(typeof module!=="undefined"&&module.exports){module.exports.saveAs=saveAs}else if(typeof define!=="undefined"&&define!==null&&define.amd!==null){define("FileSaver.js",function(){return saveAs})}

/* global Ext CArABU saveAs Blob destroyClickedElement Rally*/
Ext.define('CArABU.technicalservices.FileUtilities', {
    singleton: true,
    saveCSVToFile: function(csv, file_name, type_object) {
        if (type_object == undefined) {
            type_object = { type: 'text/csv;charset=utf-8' };
        }
        var blob = new Blob([csv], type_object);
        saveAs(blob, file_name);
    },
    saveTextAsFile: function(textToWrite, fileName) {
        var textFileAsBlob = new Blob([textToWrite], { type: 'text/plain' });
        var fileNameToSaveAs = fileName;

        var downloadLink = document.createElement("a");
        downloadLink.download = fileNameToSaveAs;
        downloadLink.innerHTML = "Download File";
        if (window.webkitURL != null) {
            // Chrome allows the link to be clicked
            // without actually adding it to the DOM.
            downloadLink.href = window.webkitURL.createObjectURL(textFileAsBlob);
        }
        else {
            // Firefox requires the link to be added to the DOM
            // before it can be clicked.
            downloadLink.href = window.URL.createObjectURL(textFileAsBlob);
            downloadLink.onclick = destroyClickedElement;
            downloadLink.style.display = "none";
            document.body.appendChild(downloadLink);
        }
        downloadLink.click();
    },
    destroyClickedElement: function(event) {
        document.body.removeChild(event.target);
    },
    convertDataArrayToCSVText: function(data_array, requestedFieldHash) {

        var text = '';
        Ext.each(Object.keys(requestedFieldHash), function(key) {
            text += requestedFieldHash[key] + ',';
        });
        text = text.replace(/,$/, '\n');

        Ext.each(data_array, function(d) {
            Ext.each(Object.keys(requestedFieldHash), function(key) {
                if (d[key]) {
                    if (typeof d[key] === 'object') {
                        if (d[key].FormattedID) {
                            text += Ext.String.format("\"{0}\",", d[key].FormattedID);
                        }
                        else if (d[key].Name) {
                            text += Ext.String.format("\"{0}\",", d[key].Name);
                        }
                        else if (!isNaN(Date.parse(d[key]))) {
                            text += Ext.String.format("\"{0}\",", Rally.util.DateTime.formatWithDefaultDateTime(d[key]));
                        }
                        else {
                            text += Ext.String.format("\"{0}\",", d[key].toString());
                        }
                    }
                    else {
                        text += Ext.String.format("\"{0}\",", d[key]);
                    }
                }
                else {
                    text += ',';
                }
            }, this);
            text = text.replace(/,$/, '\n');
        }, this);
        return text;
    },
    _getCSVFromWsapiBackedGrid: function(grid) {
        var deferred = Ext.create('Deft.Deferred');
        var store = Ext.create('Rally.data.wsapi.Store', {
            fetch: grid.getStore().config.fetch,
            filters: grid.getStore().config.filters,
            model: grid.getStore().config.model,
            limit: Infinity,
            pageSize: Infinity

        });

        var columns = grid.columns;
        var headers = this._getHeadersFromGrid(grid);
        var column_names = this._getColumnNamesFromGrid(grid);

        var record_count = grid.getStore().getTotalCount(),
            page_size = grid.getStore().pageSize,
            pages = Math.ceil(record_count / page_size),
            promises = [];

        for (var page = 1; page <= pages; page++) {
            promises.push(this.loadStorePage(grid, store, columns, page, pages));
        }
        Deft.Promise.all(promises).then({
            success: function(csvs) {
                var csv = [];
                csv.push('"' + headers.join('","') + '"');
                _.each(csvs, function(c) {
                    _.each(c, function(line) {
                        csv.push(line);
                    });
                });
                csv = csv.join('\r\n');
                deferred.resolve(csv);
                Rally.getApp().setLoading(false);
            }
        });
        return deferred.promise;
    },

    // custom grid assumes there store is fully loaded
    _getCSVFromCustomBackedGridWithPaging: function(grid) {
        var deferred = Ext.create('Deft.Deferred');


        var store = Ext.create('Rally.data.custom.Store', {
            model: grid.getStore().config.model,
            filters: grid.getStore().config.filters,
            limit: Infinity,
            pageSize: Infinity
        });

        var columns = grid.columns;
        var headers = this._getHeadersFromGrid(grid);
        var column_names = this._getColumnNamesFromGrid(grid);

        var record_count = grid.getStore().getTotalCount(),
            page_size = grid.getStore().pageSize,
            pages = Math.ceil(record_count / page_size),
            promises = [];

        // for (var page = 1; page <= pages; page ++ ) {
        //     promises.push(this.loadStorePage(grid, store, columns, page, pages));
        // }

        promises.push(this.loadStorePage(grid, store, columns, page, pages));

        Deft.Promise.all(promises).then({
            success: function(csvs) {
                var csv = [];
                csv.push('"' + headers.join('","') + '"');
                _.each(csvs, function(c) {
                    _.each(c, function(line) {
                        csv.push(line);
                    });
                });
                csv = csv.join('\r\n');
                deferred.resolve(csv);
                Rally.getApp().setLoading(false);
            }
        });
        return deferred.promise;
    },


    // custom grid assumes there store is fully loaded
    _getCSVFromCustomBackedGrid: function(grid) {
        var deferred = Ext.create('Deft.Deferred');
        var me = this;

        Rally.getApp().setLoading("Assembling data for export...");

        var headers = this._getHeadersFromGrid(grid);
        var store = Ext.clone(grid.getStore());
        var columns = grid.columns;
        var column_names = this._getColumnNamesFromGrid(grid);

        var record_count = grid.getStore().getTotalCount();
        var original_page_size = grid.getStore().pageSize;

        var page_size = 20000;
        var number_of_pages = Math.ceil(record_count / page_size);
        store.pageSize = page_size;

        var pages = [],
            promises = [];

        for (var page = 1; page <= number_of_pages; page++) {
            pages.push(page);
        }

        Ext.Array.each(pages, function(page) {
            promises.push(function() {
                return me._loadStorePage(grid, store, columns, page, pages.length)
            });
        });

        Deft.Chain.sequence(promises).then({
            success: function(csvs) {

                // set page back to last view
                store.pageSize = original_page_size;
                store.loadPage(1);

                var csv = [];
                csv.push('"' + headers.join('","') + '"');
                _.each(csvs, function(c) {
                    _.each(c, function(line) {
                        csv.push(line);
                    });
                });
                csv = csv.join('\r\n');
                deferred.resolve(csv);
                Rally.getApp().setLoading(false);
            }
        });

        return deferred.promise;
    },



    _loadStorePage: function(grid, store, columns, page, total_pages) {
        var deferred = Ext.create('Deft.Deferred');

        store.loadPage(page, {
            callback: function(records) {
                var csv = [];
                for (var i = 0; i < records.length; i++) {
                    // if(i==0){
                    //     Rally.getApp().setLoading("Loading page "+page+ " of "+total_pages);
                    // }
                    var record = records[i];
                    csv.push(this._getCSVFromRecord(record, grid, store));
                }
                deferred.resolve(csv);
            },
            scope: this
        });
        return deferred.promise;
    },


    _getHeadersFromGrid: function(grid) {
        var headers = [];
        var columns = grid.columns;

        Ext.Array.each(columns, function(column) {
            if (column.dataIndex || column.renderer) {
                if (column.csvText) {
                    headers.push(column.csvText.replace('&nbsp;', ' '));
                }
                else if (column.text) {
                    headers.push(column.text.replace('&nbsp;', ' '));
                }
            }
        });

        return headers;
    },

    _getColumnNamesFromGrid: function(grid) {
        var names = [];
        var columns = grid.columns;

        Ext.Array.each(columns, function(column) {
            if (column.dataIndex || column.renderer) {
                names.push(column.dataIndex);
            }
        });

        return names;
    },
    /*
     * will render using your grid renderer.  If you want it to ignore the grid renderer, 
     * have the column set _csvIgnoreRender: true
     */
    getCSVFromGrid: function(app, grid) {
        if (Ext.getClassName(grid.getStore()) != "Ext.data.TreeStore" &&
            Ext.getClassName(grid.getStore()) != "Rally.data.custom.Store") {
            return this._getCSVFromWsapiBackedGrid(grid);
        }

        return this._getCSVFromCustomBackedGrid(grid);
    },

    loadStorePage: function(grid, store, columns, page, total_pages) {
        var deferred = Ext.create('Deft.Deferred');

        store.loadPage(page, {
            callback: function(records, operation, success) {
                var csv = [];
                Rally.getApp().setLoading(Ext.String.format('Page {0} of {1} loaded', page, total_pages));
                for (var i = 0; i < records.length; i++) {
                    var record = records[i];
                    csv.push(this._getCSVFromRecord(record, grid, store));
                }
                deferred.resolve(csv);
            },
            scope: this
        });
        return deferred;
    },

    _getCSVFromRecord: function(record, grid, store) {
        var mock_meta_data = {
            align: "right",
            classes: [],
            cellIndex: 9,
            column: null,
            columnIndex: 9,
            innerCls: undefined,
            recordIndex: 5,
            rowIndex: 5,
            style: "",
            tdAttr: "",
            tdCls: "x-grid-cell x-grid-td x-grid-cell-headerId-gridcolumn-1029 x-grid-cell-last x-unselectable",
            unselectableAttr: "unselectable='on'"
        };

        var node_values = [];
        var columns = grid.columns;
        Ext.Array.each(columns, function(column) {
            if (column.xtype != 'rallyrowactioncolumn') {
                if (column.dataIndex) {
                    var column_name = column.dataIndex;

                    var display_value = record.get(column_name);

                    if (!column._csvIgnoreRender && column.renderer) {
                        if (column.exportRenderer) {
                            display_value = column.exportRenderer(display_value, mock_meta_data, record, 0, 0, store, grid.getView());
                        }
                        else {
                            display_value = column.renderer(display_value, mock_meta_data, record, 0, 0, store, grid.getView());
                        }
                    }
                    node_values.push(display_value);
                }
                else {
                    var display_value = null;
                    if (!column._csvIgnoreRender && column.renderer) {
                        if (column.exportRenderer) {
                            display_value = column.exportRenderer(display_value, mock_meta_data, record, record, 0, 0, store, grid.getView());
                        }
                        else {
                            display_value = column.renderer(display_value, mock_meta_data, record, record, 0, 0, store, grid.getView());
                        }
                        node_values.push(display_value);
                    }
                }

            }
        }, this);
        return '"' + node_values.join('","') + '"';
    }

});
/*
 */
Ext.define('Rally.technicalservices.Logger', {
    enableLogging: false,
    constructor: function(config) {
        Ext.apply(this, config);
    },
    log: function(args) {
        if (this.enableLogging) {
            var timestamp = "[ " + Ext.util.Format.date(new Date(), "Y-m-d H:i:s.u") + " ]";
            //var output_args = arguments;
            //output_args.unshift( [ "[ " + timestamp + " ]" ] );
            //output_args = Ext.Array.push(output_args,arguments);

            var output_args = [];
            output_args = Ext.Array.push(output_args, [timestamp]);
            output_args = Ext.Array.push(output_args, Ext.Array.slice(arguments, 0));

            window.console && console.log.apply(console, output_args);
        }
    }

});

Ext.define('CountVariableSettingsRow', {
        alias: 'widget.countvariablesettingsrow',
        extend: 'Ext.Container',

        layout: 'hbox',
        cls: 'advanced-filter-row',
        config: {
            variableName: undefined,
            artifactType: undefined,
            query: undefined,
            addButtonEnabled: false,
            removeButtonEnabled: false
        },

        constructor: function(config) {
            this.mergeConfig(config);
            this.callParent([this.config]);
        },

      initComponent: function() {
          this.items = this._getItems();
          this.callParent(arguments);
          // this.on('boxready', function() {
          //     //this.indexLabel.el.show();
          //     // if (this.focusPropertyField) {
          //     //     this.propertyField.focus();
          //     // }
          // }, this, {single: true});
      },

      _getItems: function() {

        this._createAddRowButton();

        if (!this.isEmpty){
          this._createRemoveRowButton();
          this._createIdField();
          this._createArtifactTypeField();
          this._createQueryField();

          var ct = Ext.widget({
            xtype: 'container',
            layout: 'vbox',
            height: 112,
            flex: 1,
            items: [
              this.idField,
              this.artifactTypeField,
              this.queryField
            ]
          });

          return [
            this.addRowButton,
            this.removeRowButton,
            ct
          ];
        }

        return [
            this.addRowButton
        ];

      },
      getVariableName: function(){ return this.idField.getValue();},
      getArtifactType: function(){ return this.artifactTypeField.getValue();},
      getQuery: function(){ return this.queryField.getValue();},
      disableAddRow: function() {
        this.addRowButton.addCls('variable-button-disabled');
        this.addRowButton.disable();
      },

      disableRemoveRow: function() {
        this.removeRowButton.addCls('variable-button-disabled');
        this.removeRowButton.disable();
      },
      enableRemoveRow: function() {
        this.removeRowButton.removeCls('variable-button-disabled');
        this.removeRowButton.enable();
      },
      enableAddRow: function() {
        this.addRowButton.removeCls('variable-button-disabled');
        this.addRowButton.enable();
      },

      isValid: function() {
          return !!this.idField.getValue() && !!this.artifactTypeField.getValue() && this.queryField.validate();
      },
      validate: function(){
         if (!this.idField.getValue()){ return "Please provide a value for the Variable Name.";}
         if (!this.artifactTypeField.getValue()){ return "Please provide a value for the Artifact Type."}
         if (!this.queryField.getValue()){ return "Please provide a query."}

         var queryValid = this.queryField.validate();
         if (!queryValid){ return "Invalid Query."};

         return null;
      },
      getCountVariable: function(){
          if (this.isValid()){
              var id = this.idField.getValue(),
                  artifactType = this.artifactTypeField.getValue(),
                  query = this.queryField.getValue();

              return {
                 id: id,
                 artifactType: artifactType,
                 query: query
              };
          }
      },

      _createIdField: function(){
          this.idField = Ext.widget({
              xtype: 'rallytextfield',
              itemId: 'idField',
              width: '100%',
              labelAlign:'right',
            //  labelCls: 'variable-label',
              fieldLabel: 'Variable Name',
              labelSeparator: '',
              emptyText: 'Unique Variable Name...',
              value: this.variableName,
              margin: '2 0 2 0',
              validateOnBlur: true,
              validator: function(val){
                 return val && val.length > 0;
              },
              getErrors: function(val){
                 if (!val || val.trim().length == 0){
                   return ["Please provide a value for Variable Name"]
                 }
                 return [];
              },
              listeners: {
                validitychange: function(cb,isValid){
                  this.fireEvent('rowvalidate',this);
                },
               scope: this
              }
          });
      },

      _createArtifactTypeField: function(){
        this.artifactTypeField = Ext.widget({
            xtype: 'tsrecordtypecombobox',
            itemId: 'artifactTypeField',
            width: '100%',

            labelAlign: 'right',
            fieldLabel: 'Artifact Type',
            labelSeparator: '',
          //  labelCls: 'variable-label',
            margin: '2 0 2 0',
            emptyText: 'Choose Artifact Type...',
            value: this.artifactType,
            valueField: 'TypePath',
            displayField: 'Name',
            validateOnBlur: true,
            validateOnChange: true,
            validator: function(val){
               return val && val.length > 0;
            },
            listeners: {
                validitychange: function(cb,isValid){
                  this.fireEvent('rowvalidate',this);
                },
               scope: this
            }
        });
      },

    _createQueryField: function(){
        this.queryField = Ext.widget({
          xtype: 'textarea',
          fieldLabel: null,
          width: '100%',

          labelAlign: 'right',
          labelSeparator: '',
          //labelCls: 'variable-label',
          fieldLabel: 'Query',
          margin: '2 0 2 0',
          flex: 1,
          name: 'counterQuery',
          //anchor: '100%',
          cls: 'query-field',
        //  margin: '0 70 0 0',
          plugins: [
            // {
            //   ptype: 'rallyhelpfield',
            //   helpId: 194
            // },
            'rallyfieldvalidationui'
          ],
          emptyText: 'Type a Rally Query like ( ObjectID > 0 )...',
          value: this.query || "(ObjectID > 0)",
          validateOnBlur: true,
          validateOnChange: false,
          validator: function(value) {
            if (!value){ return "Query is required."; }
            try {
              if (value) {
                Rally.data.wsapi.Filter.fromQueryString(value);
              }
              return true;
            } catch (e) {
              return e.message;
            }
          },
          listeners: {
              validitychange: function(){
                this.fireEvent('rowvalidate',this);
              },
             scope: this
          }
        });
    },

    _createAddRowButton: function() {
        var addRowCls = 'variable-button-disabled';
        if (this.addButtonEnabled){
           addRowCls = '';
        }

        this.addRowButton =  Ext.widget({
            xtype: 'rallybutton',
            itemId: 'addRowButton',
            //userAction: 'Add filter row clicked',
            cls: 'rly-small icon-plus filter-row-control variable-button ' + addRowCls,
            margin: 5,
            border: 0,
            disabled: !this.addButtonEnabled,
            listeners: {
                click: this._addRow,
                buffer: 200,
                scope: this
            }
        });
    },

    _createRemoveRowButton: function() {
        this.removeRowButton = Ext.widget({
            xtype: 'rallybutton',
            itemId: 'removeRowButton',
            //userAction: 'Remove filter row clicked',
            cls: 'rly-small icon-minus filter-row-control variable-button',
            border: 0,
            margin: 5,
            disabled: false,
            listeners: {
                click: this._removeRow,
                buffer: 200,
                scope: this
            }
        });
    },
    _addRow: function() {
        this.fireEvent('addrow', this);
    },

    _removeRow: function(autoFocus) {
        this.fireEvent('removerow', this, {autoFocus: autoFocus !== false });
    },

});

Ext.define('CountVariableSettingsComponent',{
  extend: 'Ext.form.field.Base',
       alias: 'widget.countvariablesettings',

      fieldSubTpl: '<div id="{id}" class="settings-grid"></div>',

      layout: 'vbox',
      cls: 'advanced-filter-panel',
      header: false,
      maxHeight: 350,
    //  height: 350,
      minHeight: 50,
      border: false,
      overflowY: 'auto',

      config: {
        value: undefined,
      },

      onRender: function() {
          this.callParent(arguments);

          var decodedValue = this.value;
          if (Ext.isString(decodedValue)){
             decodedValue = Ext.JSON.decode(decodedValue);
          }
          this._buildItems(decodedValue);

      },
      _buildItems: function(value) {

        var items = [];
        this.countVariableRows = [];
        Ext.Array.each(value, function(cv, i){
            var lastRow = i === value.length -1;
            var rowConfig = this._getRowConfig(cv);
            rowConfig.addButtonEnabled = lastRow;
            rowConfig.removeButtonEnabled = true;
            var item = Ext.widget(rowConfig);
            items.push(item);
            this.countVariableRows.push(item);
        },this);

        var thisHeight = this.maxHeight;
        if (Ext.isEmpty(items)) {
            this._emptyRow = Ext.widget(this._getEmptyRowConfig());
            items.push(this._emptyRow);
            thisHeight = this.minHeight;
        }

        this._countVariableContainer = Ext.widget({
          xtype: 'container',
          renderTo: this.inputEl,
          maxHeight: 300,
          // minHeight: 50,
          height: thisHeight,
          autoScroll: true,
          itemId: 'countVariableContainer',
          layout: {
            type: 'vbox',
            align: 'stretch'
          },
          cls: 'filters-container',
          items: items
        });

        if (Ext.isEmpty(items)){
          this._countVariableContainer.setHeight(this.minHeight);
        }

      },

    _getRowConfig: function(countVariable) {
        if (!countVariable){
          countVariable={};
        }
        return {
            xtype: 'countvariablesettingsrow',
            variableName: countVariable.id || '',
            artifactType: countVariable.artifactType || 'HierarchicalRequirement',
            query: countVariable.query || '',
            listeners: {
                addrow: function() {
                    this._addRow(true);
                },
                removerow: this._removeRow,
                rowvalidate: this._toggleRowButtons,
                scope: this
            }
        };
    },
    _getEmptyRowConfig: function(){

        return {
            xtype: 'countvariablesettingsrow',
            isEmpty: true,
            addButtonEnabled: true,
            itemId: 'emptyRow',
            listeners: {
                addrow: function() {
                    this._addRow(true);
                },
                scope: this
            }
        };
    },
    _addEmptyRow: function(){
      this._emptyRow = Ext.widget(this._getEmptyRowConfig());
      this._countVariableContainer.add(this._emptyRow);
      this._countVariableContainer.setHeight(this.minHeight);
    },
    _removeEmptyRow: function(){
      if (this._emptyRow){
        this._countVariableContainer.remove(this._emptyRow);
        this._emptyRow.destroy();
        this._countVariableContainer.setHeight(this.maxHeight);
      }

    },
    _addRow: function(focusOnAdd) {

        if (Ext.isEmpty(this.countVariableRows)) {
          this._removeEmptyRow();
            //_.last(this.countVariableRows).disableAddRow();
        }

        var row = Ext.widget(this._getRowConfig());
        this.countVariableRows.push(row);
        this._countVariableContainer.add(row);
    },
    _removeRow: function(row, opts) {
        var previousRowIndex = Math.max(0, _.findIndex(this.countVariableRows, row) - 1);
        _.remove(this.countVariableRows, row);
        this._countVariableContainer.remove(row);

        if (Ext.isEmpty(this.countVariableRows)) {
            //this._addRow(opts.autoFocus === false ? false : true);
            this._addEmptyRow();
        } else if (opts.autoFocus && this.countVariableRows[previousRowIndex].valueField) {
            this.countVariableRows[previousRowIndex].queryField.focus();
        }

        var lastRow = _.last(this.countVariableRows);

        if (!Ext.isEmpty(lastRow) && lastRow.isValid()) {
            lastRow.enableAddRow();
        }

        this._toggleRowButtons(lastRow);
    },

    _toggleRowButtons: function(row) {
        if (Ext.isEmpty(row)){
          return;
        }

        if (row.isValid() && row === _.last(this.countVariableRows)) {
            row.enableAddRow();
        } else {
            row.disableAddRow();
        }

        if (this.countVariableRows.length === 1){
      //    row.disableRemoveRow();
        } else {
          row.enableRemoveRow();
        }
    },

    /**
     * When a form asks for the data this field represents,
     * give it the name of this field and the ref of the selected project (or an empty string).
     * Used when persisting the value of this field.
     * @return {Object}
     */
    getSubmitData: function() {
        var data = {};
        data[this.name] = Ext.JSON.encode(this._getData());
        return data;
    },

    _getData: function() {
        var setting = [];
        Ext.Array.each(this.countVariableRows, function(cvr){
           setting.push(cvr.getCountVariable());
        });

        return setting;
    },

    getErrors: function() {
        var errors = [];
        var countVariableNames = [];
        Ext.Array.each(this.countVariableRows, function(cvr){
           var error = cvr.validate();
           if (error){
             errors.push(error);
           }

           if (Ext.Array.contains(countVariableNames, cvr.getVariableName())){
             errors.push("Duplicate Variable Names {" + cvr.getVariableName() + "}.  Variable Names must be unique.");
           } else {
             countVariableNames.push(cvr.getVariableName());
           }
        });
        return _.uniq(errors);
    },

    setValue: function(value) {
        this.callParent(arguments);
        this._value = value;
    }

});

// eslint-disable-next-line no-unused-vars
class CustomPromise {
    /**
     * @returns {Promise} the deft promise wrapped in ECMA6
     * @param {Ext.Deferred} deferred 
     */
    static async wrap(deferred) {
        if (
            !deferred ||
            !_.isFunction(deferred.then)
        ) {
            return Promise.reject(new Error('Wrap cannot process this type of data into a ECMA promise'));
        }
        return new Promise((resolve, reject) => {
            deferred.then({
                success(...args) {
                    resolve(...args);
                },
                failure(error) {
                    reject(error);
                    // Do something on failure.
                }
            }).always(() => {
                // Do something whether call succeeded or failed
            });
        });
    }
}


Ext.define('Rally.technicalservices.querycounter.Settings', {

    singleton: true,

    getFields(config) {
        let items = [];

        items.push({
          name: 'countVariables',
          fieldLabel: null,
          labelAlign: 'top',
          xtype: 'countvariablesettings',
          width: config.width * 0.90 || 600,
          margin: 10
        });

        items.push({
            xtype: 'container',
            margin: '10 70 0 60',
            html: '<div class="variable-label">Display Text</div><span style="color:#999999;">Enter the text to display in the App.  Use the format of <b>{&lt;Variable Name&gt;}</b> to place the results of the count queries defined above.</span>'
        });

        items.push({
            name: 'html',
            flex: 1,
            xtype: 'rallyrichtexteditor',
            margin: '10 70 0 60',
            fieldLabel: 'Informational Text',
            _createResizer() {}, // This is an override so that the resizer handle which is hardcoded in the component doesn't hide the last line of the editor.
            resizeable: false
        });

        return items;
    }
});

/**
 * A ComboBox showing a list of Rally record types.
 *
 *     @example
 *     Ext.create('Ext.Container', {
 *         items: [{
 *             xtype: 'tsrecordtypecombobox'
 *          }],
 *          renderTo: Ext.getBody().dom
 *     });
 */
Ext.define('Rally.technicalservices.RecordTypeComboBox', {

    extend: 'Rally.ui.combobox.ComboBox',
    alias: 'widget.tsrecordtypecombobox',

    constructor: function(config) {
        var defaultConfig = {
            defaultSelectionPosition: 'last',
            editable: false,
            fieldLabel: '',
            //labelWidth: 30,
            context: Rally.environment.getContext(),
            storeConfig: {
                autoLoad: false,
                remoteFilter: true,
                model: Ext.identityFn('TypeDefinition'),
                sorters: {
                    property: 'Name',
                    direction: 'Asc'
                },
                filters: [
                    {
                        property: 'Creatable',
                        operator: '=',
                        value: 'true'
                    }
                ]
            }
        };

        if (config.storeConfig) {
            delete config.storeConfig.autoLoad;

            if (config.storeConfig.additionalFilters) {
                defaultConfig.storeConfig.filters = defaultConfig.storeConfig.filters.concat(config.storeConfig.additionalFilters);
            }
        }

        this.callParent([Ext.Object.merge(defaultConfig, config)]);
    },

    initComponent: function() {
        this.callParent();

        Deft.Promise.all([this._loadStore()]).then({
            success: function (results) {
                this.on('change', this._onValueChange, this);
                this.onReady({ preferencesLoaded: true, record: this.getRecord() });
            },
            scope: this
        });
    },

    onReady: function (options) {
        options = options || {};

        // Only call the base onReady (which fires the 'ready' event, when both the store and preferences have loaded
        if (options.preferencesLoaded) {
            this.fireEvent('select', options.record);
            this.callParent(arguments);
        }
    },

    getSelectedType: function () {
        return this.getTypeFromRef(this.getValue());
    },

    getTypeFromRef: function (typeRef) {
        return this.getStore().findRecord('_ref', typeRef);
    },

    getTypeWithOrdinal: function(ordinal) {
        return this.getStore().findRecord("Ordinal", ordinal);
    },

    getAllTypeNames: function () {
        return _.map(this.getStore().getRecords(), function (type) { return type.get('TypePath'); });
    },

    _onValueChange: function(field, newValue) {
        this.savePreference(newValue);
    },

    _loadStore: function () {
        var deferred = new Deft.Deferred();

        this.store.load({
            callback: function (records, operation, success) {
                if (success) {
                    deferred.resolve();
                } else {
                    deferred.reject();
                }
            },
            scope: this
        });

        return deferred.promise;
    },

    getPreference: function() {
        var deferred = new Deft.Deferred();

        Rally.data.PreferenceManager.load(Ext.apply(this._getPreferenceConfig(), {
            success: function(prefs) {
                deferred.resolve(prefs[this._getPreferenceName()]);
            },
            scope: this
        }));

        return deferred.promise;
    },

    savePreference: function(value) {
        var settings = {};
        settings[this._getPreferenceName()] = value;

        Rally.data.PreferenceManager.update(Ext.apply(this._getPreferenceConfig(), {
            settings: settings
        }));
    },

    _getPreferenceConfig: function () {
        var config = {
            filterByUser: true,
            filterByName: this._getPreferenceName()
        };

        if (this.context.get && this.context.get('appID')) {
            config.appID = this.context.get('appID');
        }

        return config;
    },

    _getPreferenceName: function() {
        return this.preferenceName + '-' + this.context.getWorkspace().ObjectID;
    },

    _isPrefValueInStore: function (pref) {
        return this.store.findRecord(this.valueField, pref);
    }
});


Ext.define('TSQueryCounter', {
    extend: 'Rally.app.App',
    componentCls: 'app',
    logger: new Rally.technicalservices.Logger(),
    items: [{
        xtype: 'container',
        layout: {
            type: 'vbox',
            align: 'stretch'
        },
        items: [{
            xtype: 'container',
            layout: {
                type: 'hbox',
                align: 'middle'
            },
            items: [
                {
                    id: Utils.AncestorPiAppFilter.RENDER_AREA_ID,
                    xtype: 'container',
                    layout: {
                        type: 'hbox',
                        align: 'middle',
                        defaultMargins: '0 10 10 0',
                    }
                },
                {
                    xtype: 'rallybutton',
                    style: { float: 'right' },
                    cls: 'secondary rly-small',
                    frame: false,
                    width: 34,
                    itemId: 'export-menu-button',
                    iconCls: 'icon-export'
                }
            ]
        }, {
            id: Utils.AncestorPiAppFilter.PANEL_RENDER_AREA_ID,
            xtype: 'container',
            layout: {
                type: 'hbox',
                align: 'middle',
                defaultMargins: '0 10 10 0',
            }
        }]
    },
    {
        xtype: 'container',
        itemId: 'display_box'
    }
    ],

    config: {
        defaultSettings: {
            countVariables: [{
                artifactType: 'Defect',
                query: '( ObjectID > 0 )',
                id: 'defectCount'
            }, {
                artifactType: 'HierarchicalRequirement',
                query: '( ObjectID > 0 )',
                id: 'storyCount'
            }],
            html: 'Defects: {defectCount} or Stories: {storyCount}<br/><br/><em>Use the gear to make App Settings...</em>'
        }
    },

    currentValues: [],

    launch() {
        Rally.data.wsapi.Proxy.superclass.timeout = 120000;
        let exportButton = this.down('#export-menu-button');
        exportButton.on('click', this._onExport, this);
        this._validateSettings();

        this.ancestorFilterPlugin = Ext.create('Utils.AncestorPiAppFilter', {
            ptype: 'UtilsAncestorPiAppFilter',
            pluginId: 'ancestorFilterPlugin',
            settingsConfig: {
                labelWidth: 150,
                margin: 10
            },
            filtersHidden: false,
            listeners: {
                scope: this,
                ready(plugin) {
                    plugin.addListener({
                        scope: this,
                        select: this._runApp,
                        change: this._runApp
                    });
                    this._reloadModel().then({
                        scope: this,
                        success: this._runApp
                    });
                },
            }
        });
        this.addPlugin(this.ancestorFilterPlugin);
    },

    _onExport() {
        let csv = ['Variable Name,Value'];
        _.each(this.currentValues, (value, key) => {
            csv.push([key, value].join(','));
        });
        csv = csv.join('\r\n');
        CArABU.technicalservices.FileUtilities.saveCSVToFile(csv, 'query-counter.csv');
    },

    _validateSettings() {
        let cv = this._getCountVariables();
        let html = this.getSetting('html');
        this.logger.log('setting ', this.getSettings());
        let errors = [];
        Ext.Array.each(cv, (c) => {
            let variableName = Ext.String.format('{{0}}', c.id);
            let re = new RegExp(variableName);

            if (!re.exec(html)) {
                errors.push(`Variable Name ${variableName} not used.`);
            }
        });
        if (errors.length > 0) {
            Rally.ui.notify.Notifier.showError({ message: errors.join('<br/>'), allowHTML: true });
        }
    },

    onTimeboxScopeChange(timebox) {
        this.callParent(arguments);
        this._runApp();
    },

    _timeboxScopeIsValidForArtifactType(timeboxScope, artifactType) {
        if (timeboxScope) {
            let model = this.models[artifactType];
            this.logger.log('_timeboxScopeIsValidForArtifactType', timeboxScope.getType(), model, model.getField('Milestones'), model.getField('Iteration'), model.getField('Release'), timeboxScope.getQueryFilter().toString());
            let field = 'Release';
            // eslint-disable-next-line default-case
            switch (timeboxScope.getType()) {
                case 'iteration':
                    field = 'Iteration';
                    break;
                case 'milestone':
                    field = 'Milestones';
                    break;
            }

            if (model.getField(field)) {
                this.logger.log('TimeboxScope', timeboxScope.getType(), 'is valid for', artifactType);
                return true;
            }
            this.logger.log('TimeboxScope', timeboxScope.getType(), 'NOT valid for', artifactType);

            return false;
        }
        this.logger.log('No Timebox Scope');
        return true;
    },

    _getCountVariables() {
        let cv = this.getSetting('countVariables');
        if (Ext.isString(cv)) {
            cv = JSON.parse(cv);
        }
        return cv;
    },

    _getModelNames() {
        let countVariables = this._getCountVariables();
        this.logger.log('countVariables ', countVariables);
        let modelNames = Ext.Array.map(countVariables, v => v.artifactType);
        return _.uniq(modelNames);
    },

    _reloadModel() {
        let deferred = Ext.create('Deft.Deferred');
        if (Ext.isEmpty(this._getModelNames())) {
            deferred.resolve();
        }
        // Load the model so that we can test if it is valid for the timebox scope
        Rally.data.ModelFactory.getModels({
            types: this._getModelNames(),
            scope: this,
            success(models) {
                this.logger.log('models ', models);
                this.models = models;
                deferred.resolve();
            }
        });
        return deferred.promise;
    },

    // There is a subtle  bug on timebox
    // scoped pages where the milestone timebox is not correctly restored after a settings change.
    // 1. Set page as milestone timebox scoped
    // 2. Pick a non-null milestone timebox
    // 3. Open app settings and save (no change needed)
    // 4. Timebox will be 'milestone' in the window.location.href instead of 'milestone/12345'.
    // See getSdkInfo() in the SDK for how the timebox is restored.
    // This only seems to occur the first time after the page is made timebox scoped and goes away once
    // the page is reloaded once.
    async _runApp() {
        let me = this;
        let promisesComplete = 0;
        let promises = [];
        let ancestorFilters = {};
        me.errorCount = 0;
        me.maxErrors = 5;
        me.loadingFailed = false;

        this.setLoading('Loading Filters...');

        const refreshMask = () => {
            this.setLoading(`Counting  ${promisesComplete} complete of ${promises.length} error count ${me.errorCount}`);
        };
        const displayError = () => {
            me.errorCount++;
            refreshMask();
        };
        let timeboxScope = this.getContext().getTimeboxScope();
        let countVariables = this._getCountVariables();

        this.logger.log('_runApp', countVariables);

        for (let cv of countVariables) {
            let { artifactType } = cv;
            let { query } = cv;
            let { id } = cv;

            let filters = null;
            let ancestorFiltersForType = [];

            if (timeboxScope && this._timeboxScopeIsValidForArtifactType(timeboxScope, artifactType)) {
                filters = timeboxScope.getQueryFilter();
                this.logger.log('Using Timebox Scope >>', filters.toString(), filters);
            }

            if (!Ext.isEmpty(query)) {
                if (filters) {
                    filters = filters.and(Rally.data.wsapi.Filter.fromQueryString(query));
                } else {
                    filters = Rally.data.wsapi.Filter.fromQueryString(query);
                }
            }

            if (ancestorFilters[artifactType]) {
                ancestorFiltersForType = ancestorFilters[artifactType];
            } else {
                ancestorFiltersForType = await this.ancestorFilterPlugin.getAllFiltersForType(artifactType, true).catch((e) => {
                    this._showErrorNotification(e.message || e);
                    this.setLoading(false);
                    this.loadingFailed = true;
                });
                ancestorFilters[artifactType] = ancestorFiltersForType;
            }

            if (this.loadingFailed) {
                return;
            }

            if (ancestorFiltersForType) {
                for (let i = 0; i < ancestorFiltersForType.length; i++) {
                    if (filters) {
                        filters = filters.and(ancestorFiltersForType[i]);
                    } else {
                        filters = ancestorFiltersForType[i];
                    }
                }
            }

            let promise = this._loadRecordCount(artifactType, filters || [], id, displayError);
            promise.then((a) => {
                if (!this.loadingFailed) {
                    promisesComplete++;
                    refreshMask();
                    return a;
                }
            }).catch((e) => {
                throw new Error(e);
            });
            promises.push(promise);
        }

        if (promises.length > 0) {
            refreshMask();

            Promise.all(promises)
                .then((...args) => this._updateDisplay(...args))
                .catch((...args) => {
                    // Other promises could continue to resolve and update display so
                    // we set a flag to prevent this from happening
                    this.loadingFailed = true;
                    this._showErrorNotification(...args);
                })
                .finally(() => this.setLoading(false));
        } else {
            this._updateDisplay();
        }
    },

    _showErrorNotification(msg) {
        this.logger.log('_showErrorNotification', msg);
        Rally.ui.notify.Notifier.showError({ message: msg });
    },

    async _loadRecordCount(model, filters, id, onFailedAttempt = () => { }) {
        let deferred = Ext.create('Deft.Deferred');
        let me = this;
        this.logger.log('Starting load: model >>', model, 'filters>>', filters.toString());

        let config = {
            model,
            filters,
            limit: 1,
            pageSize: 1,
            fetch: ['_ref'],
            enablePostGet: true
        };

        if (this.searchAllProjects()) {
            config.context = {
                project: null
            };
        }

        Ext.create('Rally.data.wsapi.Store', config).load({
            callback: (records, operation, successful) => {
                let result = {};
                if (successful) {
                    me.logger.log('result:', operation);
                    result[id] = operation.resultSet.totalRecords || 0;
                    deferred.resolve(result);
                } else {
                    console.warn('Failed: ', operation);
                    onFailedAttempt(id);
                    if (me.errorCount < me.maxErrors) {
                        this._loadRecordCount(model, filters, id, onFailedAttempt)
                            .then((p) => deferred.resolve(p))
                            .catch((e) => { deferred.reject(e); });
                    }
                    else {
                        deferred.reject(this._parseException(operation, `Store failed to load for type ${model}. Filter result set may have been too large`));
                    }
                }
            },
            scope: this
        });
        return CustomPromise.wrap(deferred.promise);
    },

    _updateDisplay(values) {
        if (!values) { values = []; }

        values = _.reduce(values, (obj, v) => {
            obj = _.extend(obj, v);
            return obj;
        }, {});

        this.currentValues = values;

        this.logger.log('_updateDisplay', values);

        let html = this.getSetting('html');
        let tpl = new Ext.XTemplate(html);
        let displayBox = this.down('#display_box');
        displayBox.removeAll();
        let view = displayBox.add({
            xtype: 'container',
            tpl,
            cls: 'default-counter'
        });
        view.update(values);
    },

    isExternal() {
        return typeof (this.getAppId()) === 'undefined';
    },

    isMilestoneScoped() {
        let result = false;

        let tbscope = this.getContext().getTimeboxScope();
        if (tbscope && tbscope.getType() === 'milestone') {
            result = true;
        }
        return result;
    },

    searchAllProjects() {
        return this.ancestorFilterPlugin.getIgnoreProjectScope();
    },

    getSettingsFields() {
        return Rally.technicalservices.querycounter.Settings.getFields({
            width: this.getWidth()
        });
    },

    _parseException(e, defaultMessage) {
        if (typeof e === 'string') {
            return e;
        }
        if (e.exception && e.error && e.error.errors && e.error.errors.length && e.error.errors[0]) {
            return e.error.errors[0];
        }
        if (e.exceptions && e.exceptions.length && e.exceptions[0].error) {
            if (typeof e.exceptions[0].error === 'string') {
                return e.exceptions[0].error;
            }
            // eslint-disable-next-line no-else-return
            else if (e.exceptions[0].error.statusText) {
                return e.exceptions[0].error.statusText;
            }
        }
        console.log('Unable to parse exception', e);
        return defaultMessage;
    }

});


               Rally.launchApp('TSQueryCounter', {
                   name: 'query-counter'
               });
        });
    </script>

    <style type="text/css">

.blue-tabs .x-tab-bar .x-tab-default {
    background-color: white;
    border-radius: 4px 4px 0 0;
  }
  
  .blue-tabs .x-tab-bar .x-tab-default .x-tab-inner {
    color: #00a9e0;
  }
  
  .blue-tabs .x-tab-bar .x-tab-active {
    background-color: #00a9e0;
  }
  
  .blue-tabs .x-tab-bar .x-tab-active .x-tab-inner {
    color: white;
  }
  
  .blue-tabs .x-tab-bar .x-tab-default .x-tab-inner {
    text-overflow: initial;
    -o-text-overflow: initial;
    overflow: initial;
  }
  
  .blue-tabs .x-tab-bar .x-tab-inner {
    width: 100%;
  }
  
  .blue-tabs .x-tab-bar .x-tab-default .x-tab-icon-el {
    color: white;
  }
    </style>

</head>
<body></body>
</html>